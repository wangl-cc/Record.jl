var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#Clock","page":"References","title":"Clock","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"RecordedArrays.AbstractClock\nDiscreteClock\nContinuousClock\ncurrenttime\nlimit\nstart\ninit!\nincrease!","category":"page"},{"location":"references/#RecordedArrays.AbstractClock","page":"References","title":"RecordedArrays.AbstractClock","text":"AbstractClock{T<:Real}\n\nSupertype of clocks with time of type T.\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.DiscreteClock","page":"References","title":"RecordedArrays.DiscreteClock","text":"DiscreteClock([start], timelist)\nDiscreteClock(stop)\n\nClock for discrete-time process, time of which muse be increased with given step and can't be updated manually. The timelist must be a non-empty and monotonically increasing AbstractVector.  If the start is not specified, the first item of timelist will be deleted and set as start. During iteration, the current time will be updated automatically and returned as iteration item. When the iteration finished without break, init! will be applied.  DiscreteClock(stop) will create a clock with start=0 and timelist=Base.OneTo(stop)\n\nExamples\n\njulia> c = DiscreteClock(0:3);\n\njulia> currenttime(c)\n0\n\njulia> [(t, currenttime(c)) for t in c]\n3-element Vector{Tuple{Int64, Int64}}:\n (1, 1)\n (2, 2)\n (3, 3)\n\njulia> currenttime(c)\n0\n\njulia> c = DiscreteClock(3); # similar to DiscreteClock(0:3)\n\njulia> (currenttime(c), collect(c))\n(0, [1, 2, 3])\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.ContinuousClock","page":"References","title":"RecordedArrays.ContinuousClock","text":"ContinuousClock{T, I<:Union{Nothing, DiscreteClock}} <: AbstractClock{T}\nContinuousClock(stop, [start=zero(stop)]; [max_epoch=nothing])\n\nA clock for continuous-time process. Unlike the DiscreteClock, during iteration, the current time will not be update automatically, but update by increase! manually. Besides the epoch of current iteration instead of current time will be returned. If the max_epoch is specified, the iteration will break when epoch reach to the max_epoch, even currenttime(c) < limit(c), and break in this way the init!(c) will not be applied.\n\nExamples\n\njulia> c = ContinuousClock(3.0; max_epoch=2);\n\njulia> for epoch in c\n           increase!(c, 1)\n           println(currenttime(c), '\t', epoch)\n       end\n1.0\t1\n2.0\t2\n\njulia> for epoch in c\n           increase!(c, 1)\n           println(currenttime(c), '\t', epoch)\n       end\n3.0\t1\n\njulia> for epoch in c\n           increase!(c, 1)\n           println(currenttime(c), '\t', epoch)\n       end\n1.0\t1\n2.0\t2\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.currenttime","page":"References","title":"RecordedArrays.currenttime","text":"currenttime(c::AbstractClock)\n\nReturn current time of clock c.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.limit","page":"References","title":"RecordedArrays.limit","text":"limit(c::AbstractClock)\n\nReturn the limit of clock c. For a ContinuousClock c, the max time might larger than limit(c).\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.start","page":"References","title":"RecordedArrays.start","text":"start(c::AbstractClock)\n\nReturn the start time of clock c.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.init!","page":"References","title":"RecordedArrays.init!","text":"init!(c::AbstractClock)\n\nUpdate current time to start time.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.increase!","page":"References","title":"RecordedArrays.increase!","text":"increase!(c::ContinuousClock, t::Real)\n\nUpdate current time of clock c to currenttime(c) + t.\n\n\n\n\n\n","category":"function"},{"location":"references/#Entries","page":"References","title":"Entries","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"RecordedArrays.AbstractEntry\nStaticEntry\nDynamicEntry\ngetts\ngetvs\ntspan\ngettime\nRecordedArrays.store!\nRecordedArrays.del!","category":"page"},{"location":"references/#RecordedArrays.AbstractEntry","page":"References","title":"RecordedArrays.AbstractEntry","text":"AbstractEntry{V,T<:Real}\n\nSupertype of all entry types, which store changes of a specified variable of type V with timestamps of type T.\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.StaticEntry","page":"References","title":"RecordedArrays.StaticEntry","text":"StaticEntry{V,T} <: AbstractEntry{V,T}\n\nEntry type to store changing history of a variable whose value not changing overtime.\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.DynamicEntry","page":"References","title":"RecordedArrays.DynamicEntry","text":"DynamicEntry{V,T} <: AbstractEntry{V,T}\n\nEntry type to store changing history of a variable whose value changing overtime.\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.getts","page":"References","title":"RecordedArrays.getts","text":"getts(e::AbstractEntry{V,T}) -> Vector{T}\n\nGet timestamps of an entry e.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.getvs","page":"References","title":"RecordedArrays.getvs","text":"getvs(e::AbstractEntry{V,T}) -> Vector{V}\n\nGet values at each timestamp of an entry e.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.tspan","page":"References","title":"RecordedArrays.tspan","text":"tspan(e::AbstractEntry{V,T}) -> T\n\nGet last time of an entry e.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.gettime","page":"References","title":"RecordedArrays.gettime","text":"gettime([alg::AbstractSearch], e::AbstractEntry, t::Real)\ngettime([alg::AbstractSearch], e::AbstractEntry, ts)\ngettime([alg::AbstractSearch], es::AbstractArray{<:AbstractEntry}, t::Real)\ngettime([alg::AbstractSearch], es::AbstractArray{<:AbstractEntry}, ts)\n\nGet the value of e at t::Real or values at each time t in an iterate ts. If t is not a timestamp  in getts(e), return value at time getts(e)[i] where getts(e)[i] < t < getts(e)[i+1]. The alg is a search algorithm that finds the index i of a target time t, which can be LinearSearch or BinarySearch (by default). For es, an array of entries, return values at t as a similar array.\n\nnote: Note\nts must be monotonically increasing.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.store!","page":"References","title":"RecordedArrays.store!","text":"store!(e::AbstractEntry, v, t::Union{Real,AbstractClock})\n\nStore a entry with value v at time t.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.del!","page":"References","title":"RecordedArrays.del!","text":"del!(e::AbstractEntry, t::Union{Real,AbstractClock})\n\nMarks a entry e deleted at time t. If an AbstractClock c is given, t = currenttime(c).\n\n\n\n\n\n","category":"function"},{"location":"references/#Recorded-Types","page":"References","title":"Recorded Types","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"RecordedArrays.AbstractRecArray\nRecordedArrays.RecordedNumber\nrecorded\nstate\ngetentries\nissubtype\nisnum","category":"page"},{"location":"references/#RecordedArrays.AbstractRecArray","page":"References","title":"RecordedArrays.AbstractRecArray","text":"AbstractRecArray{T,N}\n\nSupertype of recorded N-dimensional arrays with elements of type T, whose changes will be recorded automatically.\n\nnote: Note\nAvoid to mutate recorded arrays out of loop, because clocks will initial automatically during loop.\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.RecordedNumber","page":"References","title":"RecordedArrays.RecordedNumber","text":"RecordedNumber{T}\n\nA Union of recorded numbers with type T.\n\ninfo: Info\nRecordedNumber{S} <: T will always return false where T is a subtype of Number, even if S <: T. There is a function issubtype(RecordedNumber{S}, T)  which would return true if S <: T. Besides, isnum(T, n::RecordedNumber{S}) would return true if S <: T.\n\nnote: Note\nStore a value v to an RecordedNumber x by x[] = v or x[1] = v instead of x = v.\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.recorded","page":"References","title":"RecordedArrays.recorded","text":"recorded(E, c::AbstractClock, A)\n\nCreate a recorded array (or number) with entry of type E and clock c.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.state","page":"References","title":"RecordedArrays.state","text":"state(A::AbstractRecArray{T,N}) -> Array{T,N}\nstate(x::RecordedNumber{T}) -> T\n\nGet current state of a recorded array A or a recorded number x.\n\nnote: Note\nstate for AbstractRecArray{V,T,N} where N >= 2 may be unsafe because of unsafe_wrap and unsafe_convert.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.getentries","page":"References","title":"RecordedArrays.getentries","text":"getentries(x::RecordedNumber)\n\nGet entries of a recorded number x.\n\n\n\n\n\ngetentries(A::AbstractRecArray)\n\nGet entries of a recorded array A.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.issubtype","page":"References","title":"RecordedArrays.issubtype","text":"issubtype(S, T) -> Bool\n\nSimilar to S <: T, but for a S where S <: RecordedNumber{P}, return true if P <: T.\n\n\n\n\n\n","category":"function"},{"location":"references/#RecordedArrays.isnum","page":"References","title":"RecordedArrays.isnum","text":"isnum(T, x) -> Bool\n\nSimilar to x is T, but for x where x::RecordedNumber{S}, return true if S <:T.\n\n\n\n\n\n","category":"function"},{"location":"references/#Utilities","page":"References","title":"Utilities","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"RecordedArrays.MCIndices\nRecordedArrays.DOKSparseArray","category":"page"},{"location":"references/#RecordedArrays.MCIndices","page":"References","title":"RecordedArrays.MCIndices","text":"MCIndices(sz::NTuple{N,AbstractVector{Int}}) -> R\nMCIndices(A::AbstractArray) -> R\n\nA CartesianIndices like type defines mutable and disconnected region R.\n\nExamples\n\njulia> im = MCIndices(([1, 3], [2, 4]))\n2×2 MCIndices{2}:\n (1, 2)  (1, 4)\n (3, 2)  (3, 4)\n\njulia> im[1]\n(1, 2)\n\njulia> im[1, 2]\n(1, 4)\n\n\n\n\n\n","category":"type"},{"location":"references/#RecordedArrays.DOKSparseArray","page":"References","title":"RecordedArrays.DOKSparseArray","text":"DOKSparseArray{T,N}\n\nA simple sparse array type storing as DOK format.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Define-a-Clock","page":"Manual","title":"Define a Clock","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To record changes of recorded variables automatically, those variables must refer to the time variable of model, in this package which called as a \"Clock\".","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"There are different types of clocks:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ContinuousClock for continuous-time process,\nand DiscreteClock for discrete-time process.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A clock can be created like:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"c = ContinuousClock(10.0)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"which create a ContinuousClock start at t=0 and end at t=10.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The current time of clock is accessed by currenttime. Obviously, the current time of clock will change at each epoch. For DiscreteClock, the time will update automatically during iteration, more about iteration, see below. For ContinuousClock, the time must be update manually by increase!.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Clocks can be iterated, for example, iterating a ContinuousClock:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"for epoch in c\n    # do something calculating the time step τ\n    increase!(c, τ)\n    # do something mutating states\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"which is equivalent to","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"t = 0.0\nepoch = 0\nwhile t <= 10.0\n    global epoch\n    epoch += 1\n    # do something calculating the time step τ\n    t += τ\n    # do something mutating states\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Iterate clocks by for loop is recommended, and any operations on recorded variable should be avoided out of loop. During the iteration, some states of Clock were updated automatically, and if iteration finished when reach to end, Clock will be initialized by init! automatically. Besides, iteration is the only way to update the current time of DiscreteClock.","category":"page"},{"location":"manual/#Entry-type","page":"Manual","title":"Entry type","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In this package, an entry stores changes of a single variable, a number or an element of an array. There are two types of entries:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"DynamicEntry for variable which represents a \"state\" changing overtime,\nStaticEntry for variable which represents a \"trait\"   which not changes overtime and only assigned once,   but may be added or deleted with \"mutation\" and \"extinction\".","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The different entry types determine how the variable is recorded, and how the changes is accessed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For example, a \"dynamic\" variable d firstly assigned to 1 at time t_1 and changed to 2 at time t_2, thus the value of it is 0 for t  t_1, 1 for t_1 leq t  t_2, and 2 for t_2 leq t.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"But, for a \"static\" variable s added with value 1 at time t_1 and deleted at time t_2, the value of it is 1 for t_1 leq t leq t_2, and 0 for t leq t_1 or t_2 leq t.","category":"page"},{"location":"manual/#Recorded-variable","page":"Manual","title":"Recorded variable","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"With a clock c and an entry type E recorded variables can be created by recorded:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"recorded(E, c, 1) # create a recorded number\nrecorded(E, c, [1, 2, 3]) # create a recorded array","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For recorded arrays, most operation and functions for array, like linear algebra operation and broadcasting, works the same as normal Array. Besides, with the support of my another package ResizingTools, recorded arrays can be resized by resize! at each dimensions. See its documentation for more details.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For recorded numbers, most operation for number works the same as normal Number as well. Besides, because a recorded number type is not a subtype of the specific number type, for example, typeof(recorded(E, c, 1)) is not a subtype of Int, there are two function to test type of recorded number:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"issubtype: test if a recorded number type is a subtype of given normal number type,\nisnum: test if a recorded number type is the given type number type.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For example, for a record number n = recorded(E, c, 1) isnum(Integer, n) and issubtype(Integer, typeof(n)) return true, and isnum(AbstractFloat, n) and issubtype(AbstractFloat, typeof(n)) return false.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If there are any commonly used functions were not implemented or there are any performance loss comparing to the normal number and array, leave me an issue or create a pull request on GitHub.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"However, for custom functions. Warping recorded variables with state or convert it to a normal type by convert are common solution: like:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"state(recorded(E, c, 1)) # warp a recorded number to a state\nconvert(Array, recorded(E, c, [1, 2, 3])) # convert a recorded array to an array","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nstate don't allocate but may be unsafe for matrix and higher dimension array because of Base.unsafe_wrap and Base.unsafe_convert. I'm not sure if it would cause any problem or not. If anybody know more about it, please leave me an issue.","category":"page"},{"location":"manual/#Accessing-changes","page":"Manual","title":"Accessing changes","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"As shown above, the changes of recorded variables are stored in entries. To access the changes, use getentries to get the entries:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"e = getentries(n) # get the entry of a recorded number n\nes = getentries(A) # get entries of a recorded array A","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"There are some methods to access the changes stored in entries:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"getts to get the time of each change,\ngetvs to get the value of each change,\ntspan to get the time span of the entry,\ngettime to get the value at given time(s).","category":"page"},{"location":"manual/#Plotting","page":"Manual","title":"Plotting","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"There is a two user recipes for Plots.jl:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"timeseries plots time series of given recorded variables,\nphaseportrait plots phase portrait of given recorded variables.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Both of them accept arguments with there types:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"a recorded variable, like timeseries(v) where v is a recorded variable;\na collection of entries, like timeseries(es), where es is a collection of entries;\nmultiple entries, like timeseries(e1, e2), where e1 and e2 are entries.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"See example for more information.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"During running a simulation, one of the most important but annoying part is recording and processing the changing values of state. This package provides \"recorded\" types, changes of which will be recorded automatically.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a registered package, it can be installed with the add command in the Pkg REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add RecordedArrays","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using RecordedArrays # load this package\nc = ContinuousClock(3); # define a clock\nv = recorded(DynamicEntry, c, [0, 1]) # create a recorded array with the clock\nv + v # math operations work as normal array\nv .* v # broadcast works as normal array as well\nincrease!(c, 1) # when time goes and array changes, increase the define clock firstly\nv[1] += 1 # change array's element\nincrease!(c, 1) # when time goes and array changes, increase the define clock firstly\npush!(v, 1) # push a new element\nes = getentries(v) # view recorded changes\nes[1] # the changes of the first element of `v`, which changed to 1 at `t=1`\ngettime(es[1], 0:2) # get the value of the first element at time 0, 1 and 2\nes[3] # the changes of the third element of `v`, which was pushed at `t=2`\ngettime(es[3], 0:2) # get the value of the first element at time 0, 1 and 2","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/#Gaussian-random-walk","page":"Example","title":"Gaussian random walk","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"This is a simple implementation to simulate a 2-D Gaussian random walk.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using RecordedArrays\nusing Plots\nusing Random\n\nRandom.seed!(1)\n\nc = DiscreteClock(10000) # define a clock, the particle will walk 10000 epoch\npos = recorded(DynamicEntry, c, [0.0, 0.0]) # create a position vector of the particle\n\nfor _ in c\n    pos .+= randn(2) # walk randomly at each epoch\nend\n\n# plot path of particle\nphaseportrait(pos; frame=:none, grid=false, legend=false)","category":"page"},{"location":"example/#Logistic-growth","page":"Example","title":"Logistic growth","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"This is a simple implementation of Gillespie algorithm with direct method to simulate a Logistic growth population with growth rate r=05 and carrying capacity K=100.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using RecordedArrays\nusing Plots\nusing Random\n\nRandom.seed!(1)\n\nc = ContinuousClock(100.0) # define a clock, the population will growth for 100 time unit\nn = recorded(DynamicEntry, c, 10)   # define a scalar to record population size\n\nconst r = 0.5\nconst K = 100\n\nfor _ in c\n    # evaluate a_i\n    grow = r * n         # intrinsic growth\n    comp = r * n * n / K # resource competition\n\n    summed = grow + comp  # sum a_i\n\n    τ = -log(rand()) / summed # compute time interval\n\n    increase!(c, τ) # update current time\n\n    # sample a reaction and adjust population size\n    if rand() * summed < grow\n        n[1] += 1\n    else\n        n[1] -= 1\n    end\n\n    state(n) <= 0 && break # break if population extinct\nend\n\n# plot population dynamics\ntimeseries(n; frame=:box, grid=false, legend=false)","category":"page"},{"location":"example/#Stochastic-Predator–prey-Dynamics","page":"Example","title":"Stochastic Predator–prey Dynamics","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"This is a simple implementation of Gillespie algorithm with direct method to simulate a Predator–prey Dynamics.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using RecordedArrays\nusing Plots\nusing Random\n\nRandom.seed!(1)\n\nc = ContinuousClock(100.0) # define a clock, the population will growth for 100 time unit\nn = recorded(DynamicEntry, c, [100, 100])  # define a vector to record population size (n[1] for prey, n[2] for predator)\n\nconst α = 0.5\nconst β = 0.001\nconst δ = 0.001\nconst γ = 0.5\n\nfor _ in c\n    n[2] == 0 && break\n\n    # evaluate a_i\n    grow = α * n[1] # intrinsic growth of prey\n    predation_prey = β * n[1] * n[2] # predation cause death of prey\n    predation_pred = δ * n[1] * n[2] # predation cause reproduction of predator\n    death = γ * n[2] # intrinsic death of prey\n\n    summed = grow + predation_prey + predation_pred + death\n\n    summed <= 0 && break\n\n    τ = -log(rand()) / summed # compute time interval\n\n    increase!(c, τ) # update current time\n\n    # sample a reaction and adjust population size\n    r1 = rand() * summed\n\n    if (r1 -= grow; r1 < 0)\n        n[1] += 1\n    elseif (r1 -= predation_prey; r1 < 0)\n        n[1] -= 1\n    elseif (r1 -= predation_pred; r1 < 0)\n        n[2] += 1\n    else\n        n[2] -= 1\n    end\nend\n\nts = timeseries(n; frame=:box, grid=false, legend=false)\npp = phaseportrait(n; frame=:box, grid=false, legend=false)\nplot(ts, pp; titles=[\"Population dynamics\" \"Phase portrait\"], size=(800, 400))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"More examples is hard to implement simply.","category":"page"}]
}
